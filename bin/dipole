#!/usr/bin/env bash 
if [[ $# == 0 ]]; then
  echo "dipole pp_folder nelec_1stlayer nelec_2ndlayer..."
fi
dir=$1
shift
# slab=$1 #
# shift   #
args="$@"

cd $dir
lines=$(wc -l chden.ave|cut -d ' ' -f1)
dim="$(sed -n '/!/!s/celldm.*=\s\+\(.*\),\?$/\1/p' ../input.txt)"
layers="$(awk -vargs="$args" -vd="$dim" -vl=$lines -vslab=$slab 'BEGIN{
  n = split(args, nel)
  split(d, dim) # dim[1..3], cell dimensions
  discard=0 # 24 for un-edited pp file!! first few lines to discard in chden.ave
  dz = dim[1] * dim[3] / (l-discard)
  dT = dim[1] ^ 2 * dim[2] * dz  # differential volume!
  # sbeg = (dim[1] * dim[3] - slab)/2 #
  # send = sbeg + slab #
  i = 1
} NR > discard {
    # if($1 >= sbeg && $1 <= send){ #
      new = $2*dT # total nelec ( num elec ) in current volume
      sum += new # total nelec so far
      if(sum >= nel[i] && i <= n){  # if exceeded the nelec given for the layer
        rem = sum - nel[i]          # take the excess electrons off
        # pol -= (new - rem) * ($1 + dz/2 * (1-rem/new)) 
        # printf "%f %f ", $1 + dz * (1-rem/new), pol 
        # pol = -1 * rem * ($1 + dz *( 1 - rem /(2*new))) # pol for new layer
        pol -= (new - rem) * ($1 - dz * rem / (2*new)) # add polarization only
                   # for non-excess part. z calculated by linear interpolation
        printf "%f %f ", $1 + dz * ( 0.5 - rem/new ), pol # write z (bohr), pol (e bohr)
        sum = rem  # start counting electrons for new layer
        pol = -1 * rem * ($1 + dz *  0.5 *( 1 - rem / new)) # pol for new layer
        i++
      } else {
      pol -= new * $1  # add charge * z to polarization. minus for electrons!
    }
  # } #
}' chden.ave)"
# echo $layers

awk -vd="$dim" -vl="$layers" 'BEGIN{
  n = split(l, layers)  # layers = z_layer_1_boundary P_layer_1 z_layer_2_bo...
  split(d, dim)
} NR == 2 {
  nat = $7
  ntype = $8
} NR > 4 && NR < 5 + ntype {  ## get nuclear charges of ntype different atoms
  z[++i] = $3
} NR > 4 + ntype && NR < 5 + ntype + nat { ## for each atom
  r = $4 * dim[1]    # z position
  for(i = 1; i <= n / 2; i++){
    if(r < layers[2*i-1]){
      layers[2 * i] += z[$5] * r
      break
    }
  }
} NR > 5 + ntype + nat {
  exit
} END {
  sum = 0
  vol = dim[1] ^ 3 * dim[2] * dim[3]
  for(i = 1; i<=n/2;i++) {
      printf "%9.4f %12.5f\n", layers[2*i-1], layers[2*i]
      sum += layers[2*i]
    }
  printf "  TotalP: %12.5f e * Bohr\n", sum
  printf "  TotalV: %12.5f Bohr^3\n", vol
}' chden.dat
